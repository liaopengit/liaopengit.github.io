---
layout:     post
title:      吃鸡分析
subtitle:   天命圈预测
date:       2019-03-15
author:     LP
header-img: img/PUBG Inlay.jpg
catalog: true
tags:
    - 兴趣
    - 分析
---


```python
import os 
os.chdir("pubg-finish-placement-prediction/")
%pwd
```




    '/Users/liaopeng/spyderworksapce/pubg-finish-placement-prediction'




```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import itertools
import gc
import os
import sys

sns.set_style('darkgrid')
sns.set_palette('bone')

#pd.options.display.float_format = '{:.5g}'.format
pd.options.display.float_format = '{:,.3f}'.format
```

数据获取为PUBG官方API,尝试进行了翻译，但是觉得翻译的不够准确。因此附上英文解释。


```python
DBNOs - Number of enemy players knocked.
assists - Number of enemy players this player damaged that were killed by teammates.
boosts - Number of boost items used.
damageDealt - Total damage dealt. Note: Self inflicted damage is subtracted.
headshotKills - Number of enemy players killed with headshots.
heals - Number of healing items used.
Id - Player’s Id
killPlace - Ranking in match of number of enemy players killed.
killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.) If there is a value other than -1 in rankPoints, then any 0 in killPoints should be treated as a “None”.
killStreaks - Max number of enemy players killed in a short amount of time.
kills - Number of enemy players killed.
longestKill - Longest distance between player and player killed at time of death. This may be misleading, as downing a player and driving away may lead to a large longestKill stat.
matchDuration - Duration of match in seconds.
matchId - ID to identify match. There are no matches that are in both the training and testing set.
matchType - String identifying the game mode that the data comes from. The standard modes are “solo”, “duo”, “squad”, “solo-fpp”, “duo-fpp”, and “squad-fpp”; other modes are from events or custom matches.
rankPoints - Elo-like ranking of player. This ranking is inconsistent and is being deprecated in the API’s next version, so use with caution. Value of -1 takes place of “None”.
revives - Number of times this player revived teammates.
rideDistance - Total distance traveled in vehicles measured in meters.
roadKills - Number of kills while in a vehicle.
swimDistance - Total distance traveled by swimming measured in meters.
teamKills - Number of times this player killed a teammate.
vehicleDestroys - Number of vehicles destroyed.
walkDistance - Total distance traveled on foot measured in meters.
weaponsAcquired - Number of weapons picked up.
winPoints - Win-based external ranking of player. (Think of this as an Elo ranking where only winning matters.) If there is a value other than -1 in rankPoints, then any 0 in winPoints should be treated as a “None”.
groupId - ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.
numGroups - Number of groups we have data for in the match.
maxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.
winPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.
```


```python
def toTapleList(list1,list2):
    return list(itertools.product(list1,list2))

#由于数据量具体 因此使用以下方法较少内存使用
def reduce_mem_usage(df):
    
    start_mem = df.memory_usage().sum() / 1024**2
    
    for col in df.columns:
        col_type = df[col].dtype
        
        if col_type != object:
            c_min = df[col].min()
            c_max = df[col].max()
            if str(col_type)[:3] == 'int':
                if c_min > np.iinfo(np.int8).min and c_max < np.iinfo(np.int8).max:
                    df[col] = df[col].astype(np.int8)
                elif c_min > np.iinfo(np.int16).min and c_max < np.iinfo(np.int16).max:
                    df[col] = df[col].astype(np.int16)
                elif c_min > np.iinfo(np.int32).min and c_max < np.iinfo(np.int32).max:
                    df[col] = df[col].astype(np.int32)
                elif c_min > np.iinfo(np.int64).min and c_max < np.iinfo(np.int64).max:
                    df[col] = df[col].astype(np.int64)  
            else:

                if c_min > np.finfo(np.float32).min and c_max < np.finfo(np.float32).max:
                    df[col] = df[col].astype(np.float32)
                else:
                    df[col] = df[col].astype(np.float64)

    end_mem = df.memory_usage().sum() / 1024**2
    print('Memory usage of dataframe is {:.2f} MB --> {:.2f} MB (Decreased by {:.1f}%)'.format(
        start_mem, end_mem, 100 * (start_mem - end_mem) / start_mem))
    return df
```

## Load data


```python
%%time
train = pd.read_csv('train_V2.csv')
train = reduce_mem_usage(train)
test = pd.read_csv('test_V2.csv')
test = reduce_mem_usage(test)
print(train.shape, test.shape)
```

    Memory usage of dataframe is 983.90 MB --> 339.28 MB (Decreased by 65.5%)
    Memory usage of dataframe is 413.18 MB --> 140.19 MB (Decreased by 66.1%)
    (4446966, 29) (1934174, 28)
    CPU times: user 45.7 s, sys: 14.2 s, total: 59.9 s
    Wall time: 56.9 s



```python
train.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 4446966 entries, 0 to 4446965
    Data columns (total 29 columns):
    Id                 object
    groupId            object
    matchId            object
    assists            int8
    boosts             int8
    damageDealt        float32
    DBNOs              int8
    headshotKills      int8
    heals              int8
    killPlace          int8
    killPoints         int16
    kills              int8
    killStreaks        int8
    longestKill        float32
    matchDuration      int16
    matchType          object
    maxPlace           int8
    numGroups          int8
    rankPoints         int16
    revives            int8
    rideDistance       float32
    roadKills          int8
    swimDistance       float32
    teamKills          int8
    vehicleDestroys    int8
    walkDistance       float32
    weaponsAcquired    int16
    winPoints          int16
    winPlacePerc       float32
    dtypes: float32(6), int16(5), int8(14), object(4)
    memory usage: 339.3+ MB



```python
null_cnt = train.isnull().sum().sort_values()
print('null count:', null_cnt[null_cnt > 0])
# winPlacePerc has missing data let's drop it
# dropna 
train.dropna(inplace=True)
```

    null count: winPlacePerc    1
    dtype: int64



```python
#参数的意义是只对数值数据进行描述性统计 并且进行转置操作
train.describe(include=np.number).drop('count').T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>assists</th>
      <td>0.234</td>
      <td>0.589</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>22.000</td>
    </tr>
    <tr>
      <th>boosts</th>
      <td>1.107</td>
      <td>1.716</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>2.000</td>
      <td>33.000</td>
    </tr>
    <tr>
      <th>damageDealt</th>
      <td>130.633</td>
      <td>169.887</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>84.240</td>
      <td>186.000</td>
      <td>6,616.000</td>
    </tr>
    <tr>
      <th>DBNOs</th>
      <td>0.658</td>
      <td>1.146</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1.000</td>
      <td>53.000</td>
    </tr>
    <tr>
      <th>headshotKills</th>
      <td>0.227</td>
      <td>0.602</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>64.000</td>
    </tr>
    <tr>
      <th>heals</th>
      <td>1.370</td>
      <td>2.680</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>2.000</td>
      <td>80.000</td>
    </tr>
    <tr>
      <th>killPlace</th>
      <td>47.599</td>
      <td>27.463</td>
      <td>1.000</td>
      <td>24.000</td>
      <td>47.000</td>
      <td>71.000</td>
      <td>101.000</td>
    </tr>
    <tr>
      <th>killPoints</th>
      <td>505.006</td>
      <td>627.505</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1,172.000</td>
      <td>2,170.000</td>
    </tr>
    <tr>
      <th>kills</th>
      <td>0.925</td>
      <td>1.558</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1.000</td>
      <td>72.000</td>
    </tr>
    <tr>
      <th>killStreaks</th>
      <td>0.544</td>
      <td>0.711</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1.000</td>
      <td>20.000</td>
    </tr>
    <tr>
      <th>longestKill</th>
      <td>22.993</td>
      <td>51.476</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>21.320</td>
      <td>1,094.000</td>
    </tr>
    <tr>
      <th>matchDuration</th>
      <td>1,579.506</td>
      <td>258.740</td>
      <td>9.000</td>
      <td>1,367.000</td>
      <td>1,438.000</td>
      <td>1,851.000</td>
      <td>2,237.000</td>
    </tr>
    <tr>
      <th>maxPlace</th>
      <td>44.505</td>
      <td>23.828</td>
      <td>1.000</td>
      <td>28.000</td>
      <td>30.000</td>
      <td>49.000</td>
      <td>100.000</td>
    </tr>
    <tr>
      <th>numGroups</th>
      <td>43.008</td>
      <td>23.289</td>
      <td>1.000</td>
      <td>27.000</td>
      <td>30.000</td>
      <td>47.000</td>
      <td>100.000</td>
    </tr>
    <tr>
      <th>rankPoints</th>
      <td>892.010</td>
      <td>736.648</td>
      <td>-1.000</td>
      <td>-1.000</td>
      <td>1,443.000</td>
      <td>1,500.000</td>
      <td>5,910.000</td>
    </tr>
    <tr>
      <th>revives</th>
      <td>0.165</td>
      <td>0.472</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>39.000</td>
    </tr>
    <tr>
      <th>rideDistance</th>
      <td>606.092</td>
      <td>1,496.470</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.191</td>
      <td>40,710.000</td>
    </tr>
    <tr>
      <th>roadKills</th>
      <td>0.003</td>
      <td>0.073</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>18.000</td>
    </tr>
    <tr>
      <th>swimDistance</th>
      <td>4.509</td>
      <td>30.238</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>3,823.000</td>
    </tr>
    <tr>
      <th>teamKills</th>
      <td>0.024</td>
      <td>0.167</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>12.000</td>
    </tr>
    <tr>
      <th>vehicleDestroys</th>
      <td>0.008</td>
      <td>0.093</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>5.000</td>
    </tr>
    <tr>
      <th>walkDistance</th>
      <td>1,148.517</td>
      <td>1,180.553</td>
      <td>0.000</td>
      <td>155.100</td>
      <td>685.600</td>
      <td>1,976.000</td>
      <td>25,780.000</td>
    </tr>
    <tr>
      <th>weaponsAcquired</th>
      <td>3.660</td>
      <td>2.457</td>
      <td>0.000</td>
      <td>2.000</td>
      <td>3.000</td>
      <td>5.000</td>
      <td>236.000</td>
    </tr>
    <tr>
      <th>winPoints</th>
      <td>606.460</td>
      <td>739.700</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>1,495.000</td>
      <td>2,013.000</td>
    </tr>
    <tr>
      <th>winPlacePerc</th>
      <td>0.473</td>
      <td>0.307</td>
      <td>0.000</td>
      <td>0.200</td>
      <td>0.458</td>
      <td>0.741</td>
      <td>1.000</td>
    </tr>
  </tbody>
</table>
</div>



## Data Analysis

### Id, groupId, matchId


```python
#查看数据有多少个不同值
for c in ['Id','groupId','matchId']:
    print(f'unique [{c}] count:', train[c].nunique())
```

    unique [Id] count: 4446965
    unique [groupId] count: 2026744
    unique [matchId] count: 47964


### matchType
There are 3 game modes in the game. One can play solo, or with a friend (duo), or with 3 other friends (squad).


```python
fig, ax = plt.subplots(1, 2, figsize=(12, 4))
# first 函数使得条形图按照顺序排列
train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[0])

'''
solo  <-- solo,solo-fpp,normal-solo,normal-solo-fpp
duo   <-- duo,duo-fpp,normal-duo,normal-duo-fpp,crashfpp,crashtpp
squad <-- squad,squad-fpp,normal-squad,normal-squad-fpp,flarefpp,flaretpp
'''
mapper = lambda x: 'solo' if ('solo' in x) else 'duo' if ('duo' in x) or ('crash' in x) else 'squad'
train['matchType'] = train['matchType'].apply(mapper)
train.groupby('matchId')['matchType'].first().value_counts().plot.bar(ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1ab03a2518>




![png](/img/output_14_1.png)


### cause by computer only groups?


```python
print(len(train))
```

    4446966



```python
#numGroups与maxPlace匹配  不匹配
for q in ['numGroups == maxPlace','numGroups != maxPlace']:
    print(q, ':', len(train.query(q)))
# 不匹配的原因大概率是机器人的存在
```

    numGroups == maxPlace : 1241089
    numGroups != maxPlace : 3205876


### groups in match


```python
# describe
cols = ['numGroups','maxPlace']
desc1 = train.groupby('matchType')[cols].describe()[toTapleList(cols,['min','mean','max'])]
# groups in match
group = train.groupby(['matchType','matchId','groupId']).count().groupby(['matchType','matchId']).size().to_frame('groups in match')
desc2 = group.groupby('matchType').describe()[toTapleList(['groups in match'],['min','mean','max'])]

pd.concat([desc1, desc2], axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">numGroups</th>
      <th colspan="3" halign="left">maxPlace</th>
      <th colspan="3" halign="left">groups in match</th>
    </tr>
    <tr>
      <th></th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
    </tr>
    <tr>
      <th>matchType</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>duo</th>
      <td>1.000</td>
      <td>45.812</td>
      <td>52.000</td>
      <td>3.000</td>
      <td>47.609</td>
      <td>52.000</td>
      <td>1.000</td>
      <td>45.349</td>
      <td>52.000</td>
    </tr>
    <tr>
      <th>solo</th>
      <td>1.000</td>
      <td>91.115</td>
      <td>100.000</td>
      <td>2.000</td>
      <td>93.909</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>85.680</td>
      <td>100.000</td>
    </tr>
    <tr>
      <th>squad</th>
      <td>2.000</td>
      <td>27.039</td>
      <td>37.000</td>
      <td>2.000</td>
      <td>27.983</td>
      <td>37.000</td>
      <td>2.000</td>
      <td>26.835</td>
      <td>37.000</td>
    </tr>
  </tbody>
</table>
</div>



## players

### players in match, group
一句游戏会有100位玩家参与 因此双排应该有50支队伍 4排应该有25支队伍


```python
match = train.groupby(['matchType','matchId']).size().to_frame('players in match')
group = train.groupby(['matchType','matchId','groupId']).size().to_frame('players in group')
pd.concat([match.groupby('matchType').describe()[toTapleList(['players in match'],['min','mean','max'])], 
           group.groupby('matchType').describe()[toTapleList(['players in group'],['min','mean','max'])]], axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">players in match</th>
      <th colspan="3" halign="left">players in group</th>
    </tr>
    <tr>
      <th></th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
    </tr>
    <tr>
      <th>matchType</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>crashfpp</th>
      <td>20.000</td>
      <td>86.123</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>2.009</td>
      <td>10.000</td>
    </tr>
    <tr>
      <th>crashtpp</th>
      <td>59.000</td>
      <td>74.200</td>
      <td>90.000</td>
      <td>1.000</td>
      <td>2.061</td>
      <td>7.000</td>
    </tr>
    <tr>
      <th>duo</th>
      <td>38.000</td>
      <td>93.442</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>2.059</td>
      <td>16.000</td>
    </tr>
    <tr>
      <th>duo-fpp</th>
      <td>7.000</td>
      <td>93.850</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>2.049</td>
      <td>72.000</td>
    </tr>
    <tr>
      <th>flarefpp</th>
      <td>60.000</td>
      <td>79.778</td>
      <td>96.000</td>
      <td>1.000</td>
      <td>3.590</td>
      <td>17.000</td>
    </tr>
    <tr>
      <th>flaretpp</th>
      <td>57.000</td>
      <td>86.379</td>
      <td>97.000</td>
      <td>1.000</td>
      <td>3.604</td>
      <td>18.000</td>
    </tr>
    <tr>
      <th>normal-duo</th>
      <td>8.000</td>
      <td>16.583</td>
      <td>39.000</td>
      <td>1.000</td>
      <td>1.970</td>
      <td>5.000</td>
    </tr>
    <tr>
      <th>normal-duo-fpp</th>
      <td>7.000</td>
      <td>34.741</td>
      <td>98.000</td>
      <td>1.000</td>
      <td>1.950</td>
      <td>7.000</td>
    </tr>
    <tr>
      <th>normal-solo</th>
      <td>6.000</td>
      <td>14.174</td>
      <td>47.000</td>
      <td>1.000</td>
      <td>1.405</td>
      <td>7.000</td>
    </tr>
    <tr>
      <th>normal-solo-fpp</th>
      <td>2.000</td>
      <td>17.521</td>
      <td>58.000</td>
      <td>1.000</td>
      <td>1.371</td>
      <td>10.000</td>
    </tr>
    <tr>
      <th>normal-squad</th>
      <td>13.000</td>
      <td>32.250</td>
      <td>99.000</td>
      <td>1.000</td>
      <td>4.161</td>
      <td>10.000</td>
    </tr>
    <tr>
      <th>normal-squad-fpp</th>
      <td>6.000</td>
      <td>47.972</td>
      <td>95.000</td>
      <td>1.000</td>
      <td>4.348</td>
      <td>74.000</td>
    </tr>
    <tr>
      <th>solo</th>
      <td>11.000</td>
      <td>79.209</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>1.079</td>
      <td>21.000</td>
    </tr>
    <tr>
      <th>solo-fpp</th>
      <td>1.000</td>
      <td>94.517</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>1.025</td>
      <td>64.000</td>
    </tr>
    <tr>
      <th>squad</th>
      <td>18.000</td>
      <td>94.101</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>3.538</td>
      <td>28.000</td>
    </tr>
    <tr>
      <th>squad-fpp</th>
      <td>5.000</td>
      <td>94.541</td>
      <td>100.000</td>
      <td>1.000</td>
      <td>3.470</td>
      <td>31.000</td>
    </tr>
  </tbody>
</table>
</div>



### Too many group players


```python
print(group['players in group'].nlargest(5))
del match,group
```

    matchType  matchId         groupId       
    squad      b30f3d87189aa6  14d6b54cdec6bc    74
    duo        3e029737889ce9  b8275198faa03b    72
    solo       41a634f62f86b7  128b07271aa012    64
    duo        7e93ce71ac6f61  7385e5fe214021    49
    squad      3c2531adf5b942  e52a2e6ca30474    36
    Name: players in group, dtype: int64



```python
''' 查看 matchId=='41a634f62f86b7', groupId=='128b07271aa012'
'''
subset = train[train['matchId']=='41a634f62f86b7']
sub_grp = subset[subset['groupId']=='128b07271aa012']

print('matchId==\'41a634f62f86b7\' & groupId==\'128b07271aa012\'')
print('-'*50)
print('players:',len(subset))
print('groups:',subset['groupId'].nunique())
print('numGroups:',subset['numGroups'].unique())
print('maxPlace:',subset['maxPlace'].unique())
print('-'*50)
print('max-group players:',len(sub_grp))
print('max-group winPlacePerc:',sub_grp['winPlacePerc'].unique())
print('-'*50)
print('winPlacePerc:',subset['winPlacePerc'].sort_values().unique())
```

    matchId=='41a634f62f86b7' & groupId=='128b07271aa012'
    --------------------------------------------------
    players: 97
    groups: 34
    numGroups: [34]
    maxPlace: [97]
    --------------------------------------------------
    max-group players: 64
    max-group winPlacePerc: [0.28119999]
    --------------------------------------------------
    winPlacePerc: [0.         0.0104     0.0208     0.0312     0.0417     0.0521
     0.0625     0.0729     0.0833     0.0938     0.1042     0.1146
     0.125      0.1354     0.14579999 0.15620001 0.16670001 0.1771
     0.1875     0.1979     0.20829999 0.21879999 0.22920001 0.2396
     0.25       0.2604     0.27079999 0.28119999 0.7604     0.77079999
     0.89579999 0.91670001 0.9896     1.        ]


### Plot players in group


```python
group = train.groupby(['matchId','groupId','matchType'])['Id'].count().to_frame('players').reset_index()
group.loc[group['players'] > 4, 'players'] = '5+'
group['players'] = group['players'].astype(str)

fig, ax = plt.subplots(1, 3, figsize=(16, 4))
for mt, ax in zip(['solo','duo','squad'], ax.ravel()):
    ax.set_xlabel(mt)
    group[group['matchType'] == mt]['players'].value_counts().sort_index().plot.bar(ax=ax)
```


![png](/img/output_27_0.png)


## matchDuration


```python
fig, ax = plt.subplots(1, 2, figsize=(12, 4))
train['matchDuration'].hist(bins=50, ax=ax[0])
train.query('matchDuration >= 1400 & matchDuration <= 1800')['matchDuration'].hist(bins=50, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a1c65ea20>




![png](output_29_1.png)


### min matchDuration


```python
train[train['matchDuration'] == train['matchDuration'].min()].head()
```

### max matchDuration


```python
train[train['matchDuration'] == train['matchDuration'].max()].head()
```

### same match is same duration


```python
(train.groupby('matchId')['matchDuration'].nunique() > 1).any()
```




    False



## boosts, heals


```python
fig, ax = plt.subplots(2, 2, figsize=(16, 8))

cols = ['boosts','heals']
for col, ax in zip(cols, ax):
    sub = train[['winPlacePerc',col]].copy()
    mv = (sub[col].max() // 5) + 1
    sub[col] = pd.cut(sub[col], [5*x for x in range(0,mv)], right=False)
    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
    train[col].hist(bins=20, ax=ax[1])
```


![png](/img/output_37_0.png)


## revives


```python
print('solo player has revives:', 'solo' in train.query('revives > 0')['matchType'].unique())
```

    solo player has revives: False



```python
fig, ax = plt.subplots(1, 2, figsize=(16, 4))
col = 'revives'
sub = train.loc[~train['matchType'].str.contains('solo'),['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [5*x for x in range(0,8)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[col].hist(bins=20, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a1e1e41d0>




![png](/img/output_40_1.png)


## killPlace


```python
train.groupby(['matchType'])['killPlace'].describe()[['min','mean','max']]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
    </tr>
    <tr>
      <th>matchType</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>duo</th>
      <td>1.000</td>
      <td>47.471</td>
      <td>100.000</td>
    </tr>
    <tr>
      <th>solo</th>
      <td>1.000</td>
      <td>47.458</td>
      <td>100.000</td>
    </tr>
    <tr>
      <th>squad</th>
      <td>1.000</td>
      <td>47.712</td>
      <td>101.000</td>
    </tr>
  </tbody>
</table>
</div>




```python
plt.figure(figsize=(8,4))
col = 'killPlace'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [10*x for x in range(0,11)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar()
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a1e1f7d30>




![png](/img/output_43_1.png)


### killPlace is a sorted ranking of kills and winPlacePerc in each match


```python
''' important 
'''
subMatch = train[train['matchId'] == train['matchId'].min()].sort_values(['winPlacePerc','killPlace'])
cols = ['groupId','kills','winPlacePerc','killPlace']
subMatch[cols]
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>groupId</th>
      <th>kills</th>
      <th>winPlacePerc</th>
      <th>killPlace</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3895898</th>
      <td>3a6addfa0df938</td>
      <td>0</td>
      <td>0.000</td>
      <td>94</td>
    </tr>
    <tr>
      <th>3599150</th>
      <td>3a6addfa0df938</td>
      <td>0</td>
      <td>0.000</td>
      <td>95</td>
    </tr>
    <tr>
      <th>4367296</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>88</td>
    </tr>
    <tr>
      <th>4131025</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>89</td>
    </tr>
    <tr>
      <th>3088817</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>90</td>
    </tr>
    <tr>
      <th>2290792</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>91</td>
    </tr>
    <tr>
      <th>1998699</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>92</td>
    </tr>
    <tr>
      <th>1425950</th>
      <td>236ab9e9c081b9</td>
      <td>0</td>
      <td>0.037</td>
      <td>93</td>
    </tr>
    <tr>
      <th>329124</th>
      <td>e8ff1c0fe7f6aa</td>
      <td>0</td>
      <td>0.074</td>
      <td>84</td>
    </tr>
    <tr>
      <th>729840</th>
      <td>e8ff1c0fe7f6aa</td>
      <td>0</td>
      <td>0.074</td>
      <td>85</td>
    </tr>
    <tr>
      <th>609078</th>
      <td>e8ff1c0fe7f6aa</td>
      <td>0</td>
      <td>0.074</td>
      <td>86</td>
    </tr>
    <tr>
      <th>3961031</th>
      <td>e8ff1c0fe7f6aa</td>
      <td>0</td>
      <td>0.074</td>
      <td>87</td>
    </tr>
    <tr>
      <th>134000</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>78</td>
    </tr>
    <tr>
      <th>4064127</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>79</td>
    </tr>
    <tr>
      <th>3557894</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>80</td>
    </tr>
    <tr>
      <th>2876513</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>81</td>
    </tr>
    <tr>
      <th>2368895</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>82</td>
    </tr>
    <tr>
      <th>2043479</th>
      <td>97364d4199bf30</td>
      <td>0</td>
      <td>0.111</td>
      <td>83</td>
    </tr>
    <tr>
      <th>2850875</th>
      <td>dc8f83946f97a9</td>
      <td>0</td>
      <td>0.148</td>
      <td>75</td>
    </tr>
    <tr>
      <th>3996954</th>
      <td>dc8f83946f97a9</td>
      <td>0</td>
      <td>0.148</td>
      <td>76</td>
    </tr>
    <tr>
      <th>1136390</th>
      <td>dc8f83946f97a9</td>
      <td>0</td>
      <td>0.148</td>
      <td>77</td>
    </tr>
    <tr>
      <th>90709</th>
      <td>909fe185a8cdec</td>
      <td>1</td>
      <td>0.185</td>
      <td>34</td>
    </tr>
    <tr>
      <th>3924168</th>
      <td>909fe185a8cdec</td>
      <td>1</td>
      <td>0.185</td>
      <td>35</td>
    </tr>
    <tr>
      <th>1847687</th>
      <td>909fe185a8cdec</td>
      <td>0</td>
      <td>0.185</td>
      <td>71</td>
    </tr>
    <tr>
      <th>2841348</th>
      <td>909fe185a8cdec</td>
      <td>0</td>
      <td>0.185</td>
      <td>72</td>
    </tr>
    <tr>
      <th>485219</th>
      <td>909fe185a8cdec</td>
      <td>0</td>
      <td>0.185</td>
      <td>73</td>
    </tr>
    <tr>
      <th>2082031</th>
      <td>909fe185a8cdec</td>
      <td>0</td>
      <td>0.185</td>
      <td>74</td>
    </tr>
    <tr>
      <th>3573456</th>
      <td>e84bd83822d783</td>
      <td>4</td>
      <td>0.222</td>
      <td>10</td>
    </tr>
    <tr>
      <th>1535038</th>
      <td>e84bd83822d783</td>
      <td>2</td>
      <td>0.222</td>
      <td>22</td>
    </tr>
    <tr>
      <th>3372754</th>
      <td>e84bd83822d783</td>
      <td>0</td>
      <td>0.222</td>
      <td>69</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>7931</th>
      <td>7bd08592bb25e2</td>
      <td>0</td>
      <td>0.667</td>
      <td>41</td>
    </tr>
    <tr>
      <th>3488471</th>
      <td>7bd08592bb25e2</td>
      <td>0</td>
      <td>0.667</td>
      <td>42</td>
    </tr>
    <tr>
      <th>3253562</th>
      <td>7bd08592bb25e2</td>
      <td>0</td>
      <td>0.667</td>
      <td>43</td>
    </tr>
    <tr>
      <th>1333814</th>
      <td>7bd08592bb25e2</td>
      <td>0</td>
      <td>0.667</td>
      <td>44</td>
    </tr>
    <tr>
      <th>1330902</th>
      <td>6c44ef4381fe8d</td>
      <td>6</td>
      <td>0.704</td>
      <td>4</td>
    </tr>
    <tr>
      <th>3832684</th>
      <td>6c44ef4381fe8d</td>
      <td>2</td>
      <td>0.704</td>
      <td>17</td>
    </tr>
    <tr>
      <th>4124552</th>
      <td>6c44ef4381fe8d</td>
      <td>2</td>
      <td>0.704</td>
      <td>18</td>
    </tr>
    <tr>
      <th>1159129</th>
      <td>b947dfc5cf2d02</td>
      <td>1</td>
      <td>0.741</td>
      <td>28</td>
    </tr>
    <tr>
      <th>518453</th>
      <td>b947dfc5cf2d02</td>
      <td>0</td>
      <td>0.741</td>
      <td>39</td>
    </tr>
    <tr>
      <th>2785098</th>
      <td>6620b219ed2ee2</td>
      <td>2</td>
      <td>0.778</td>
      <td>15</td>
    </tr>
    <tr>
      <th>3737125</th>
      <td>6620b219ed2ee2</td>
      <td>2</td>
      <td>0.778</td>
      <td>16</td>
    </tr>
    <tr>
      <th>2251382</th>
      <td>6620b219ed2ee2</td>
      <td>0</td>
      <td>0.778</td>
      <td>37</td>
    </tr>
    <tr>
      <th>1185914</th>
      <td>6620b219ed2ee2</td>
      <td>0</td>
      <td>0.778</td>
      <td>38</td>
    </tr>
    <tr>
      <th>1311431</th>
      <td>bf80d0d49c12dc</td>
      <td>2</td>
      <td>0.815</td>
      <td>14</td>
    </tr>
    <tr>
      <th>116020</th>
      <td>a572193b2af137</td>
      <td>7</td>
      <td>0.852</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2929488</th>
      <td>a572193b2af137</td>
      <td>4</td>
      <td>0.852</td>
      <td>9</td>
    </tr>
    <tr>
      <th>799262</th>
      <td>a572193b2af137</td>
      <td>1</td>
      <td>0.852</td>
      <td>27</td>
    </tr>
    <tr>
      <th>2313767</th>
      <td>c0f2e306380d3c</td>
      <td>2</td>
      <td>0.889</td>
      <td>13</td>
    </tr>
    <tr>
      <th>4367691</th>
      <td>c0f2e306380d3c</td>
      <td>1</td>
      <td>0.889</td>
      <td>25</td>
    </tr>
    <tr>
      <th>3852802</th>
      <td>c0f2e306380d3c</td>
      <td>1</td>
      <td>0.889</td>
      <td>26</td>
    </tr>
    <tr>
      <th>2782793</th>
      <td>c0f2e306380d3c</td>
      <td>0</td>
      <td>0.889</td>
      <td>36</td>
    </tr>
    <tr>
      <th>869835</th>
      <td>e3c34468e32d8c</td>
      <td>4</td>
      <td>0.926</td>
      <td>7</td>
    </tr>
    <tr>
      <th>2437212</th>
      <td>e3c34468e32d8c</td>
      <td>4</td>
      <td>0.926</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2858339</th>
      <td>e3c34468e32d8c</td>
      <td>3</td>
      <td>0.926</td>
      <td>11</td>
    </tr>
    <tr>
      <th>2075379</th>
      <td>ca058240046b4c</td>
      <td>6</td>
      <td>0.963</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1303528</th>
      <td>ca058240046b4c</td>
      <td>6</td>
      <td>0.963</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3637258</th>
      <td>ca058240046b4c</td>
      <td>5</td>
      <td>0.963</td>
      <td>6</td>
    </tr>
    <tr>
      <th>2351120</th>
      <td>ca058240046b4c</td>
      <td>1</td>
      <td>0.963</td>
      <td>24</td>
    </tr>
    <tr>
      <th>2848198</th>
      <td>4d1bbbc19b9084</td>
      <td>5</td>
      <td>1.000</td>
      <td>5</td>
    </tr>
    <tr>
      <th>20251</th>
      <td>4d1bbbc19b9084</td>
      <td>1</td>
      <td>1.000</td>
      <td>23</td>
    </tr>
  </tbody>
</table>
<p>95 rows × 4 columns</p>
</div>



### kills


```python
fig, ax = plt.subplots(1, 2, figsize=(16, 4))

col = 'kills'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], [5*x for x in range(0,20)], right=False)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[train['kills'] < 20][col].hist(bins=20, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a1d439240>




![png](/img/output_47_1.png)


### kills summary of match


```python
sub = train['matchType'].str.contains('solo')
pd.concat([train.loc[sub].groupby('matchId')['kills'].sum().describe(),
         train.loc[~sub].groupby('matchId')['kills'].sum().describe()], keys=['solo','team'], axis=1).T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>solo</th>
      <td>8,094.000</td>
      <td>83.421</td>
      <td>27.592</td>
      <td>0.000</td>
      <td>84.000</td>
      <td>89.000</td>
      <td>92.000</td>
      <td>786.000</td>
    </tr>
    <tr>
      <th>team</th>
      <td>39,870.000</td>
      <td>86.212</td>
      <td>17.269</td>
      <td>0.000</td>
      <td>83.000</td>
      <td>87.000</td>
      <td>90.000</td>
      <td>687.000</td>
    </tr>
  </tbody>
</table>
</div>



## killStreaks, DBNOs


```python
fig, ax = plt.subplots(2, 2, figsize=(16, 8))

cols = ['killStreaks','DBNOs']
for col, ax in zip(cols, ax):
    sub = train[['winPlacePerc',col]].copy()
    sub[col] = pd.cut(sub[col], 6)
    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
    train[col].hist(bins=20, ax=ax[1])
```


![png](/img/output_51_0.png)


## headshotKills, roadKills, teamKills


```python
fig, ax = plt.subplots(3, 2, figsize=(16, 12))

cols = ['headshotKills','roadKills','teamKills']
for col, ax in zip(cols, ax):
    sub = train[['winPlacePerc',col]].copy()
    sub.loc[sub[col] >= 5, col] = '5+'  
    sub[col] = sub[col].astype(str)
    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
    train[col].hist(bins=20, ax=ax[1])
```


![png](/img/output_53_0.png)


## assists


```python
fig, ax = plt.subplots(1, 2, figsize=(16, 4))

col = 'assists'
sub = train[['winPlacePerc',col]].copy()
sub.loc[sub[col] >= 5, col] = '5+'  
sub[col] = sub[col].astype(str)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[col].hist(bins=20, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a463a4eb8>




![png](/img/output_55_1.png)



```python
pd.concat([train[train['matchType'] == 'solo'].describe()['assists'],
           train[train['matchType'] != 'solo'].describe()['assists']],
          keys=['solo','team'], axis=1).T
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>std</th>
      <th>min</th>
      <th>25%</th>
      <th>50%</th>
      <th>75%</th>
      <th>max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>solo</th>
      <td>720,712.000</td>
      <td>0.062</td>
      <td>0.298</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>22.000</td>
    </tr>
    <tr>
      <th>team</th>
      <td>3,726,253.000</td>
      <td>0.267</td>
      <td>0.624</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>17.000</td>
    </tr>
  </tbody>
</table>
</div>



## longestKill


```python
fig, ax = plt.subplots(1, 2, figsize=(16, 4))

col = 'longestKill'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], 6)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[col].hist(bins=20, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a454f53c8>




![png](/img/output_58_1.png)


## damageDealt


```python
fig, ax = plt.subplots(1, 2, figsize=(16, 4))

col = 'damageDealt'
sub = train[['winPlacePerc',col]].copy()
sub[col] = pd.cut(sub[col], 6)
sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
train[col].hist(bins=20, ax=ax[1])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1a1f1bb198>




![png](/img/output_60_1.png)


what this mean?


```python
train.query('damageDealt == 0 & (kills > 0 | DBNOs > 0)')[
    ['damageDealt','kills','DBNOs','headshotKills','roadKills','teamKills']].head(20)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>damageDealt</th>
      <th>kills</th>
      <th>DBNOs</th>
      <th>headshotKills</th>
      <th>roadKills</th>
      <th>teamKills</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>150</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>589</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>707</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>892</th>
      <td>0.000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>942</th>
      <td>0.000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>949</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1011</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1468</th>
      <td>0.000</td>
      <td>0</td>
      <td>2</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1625</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2111</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2356</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2411</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2448</th>
      <td>0.000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2822</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2837</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2849</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2850</th>
      <td>0.000</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2984</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3011</th>
      <td>0.000</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3042</th>
      <td>0.000</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



## walkDistance, rideDistance, swimDistance¶


```python
fig, ax = plt.subplots(3, 2, figsize=(16, 12))

cols = ['walkDistance', 'rideDistance', 'swimDistance']
for col, ax in zip(cols, ax):
    sub = train[['winPlacePerc',col]].copy()
    sub[col] = pd.cut(sub[col], 6)
    sub.groupby(col).mean()['winPlacePerc'].plot.bar(ax=ax[0])
    train[col].hist(bins=20, ax=ax[1])
```


![png](/img/output_64_0.png)



```python
sub = train[['walkDistance','rideDistance','swimDistance','winPlacePerc']].copy()
walk = train['walkDistance']
sub['walkDistanceBin'] = pd.cut(walk, [0, 0.001, walk.quantile(.25), walk.quantile(.5), walk.quantile(.75), 99999])
sub['rideDistanceBin'] = (train['rideDistance'] > 0).astype(int)
sub['swimDistanceBin'] = (train['swimDistance'] > 0).astype(int)

fig, ax = plt.subplots(1, 3, figsize=(16, 3), sharey=True)
sub.groupby('walkDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[0])
sub.groupby('rideDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[1])
sub.groupby('swimDistanceBin').mean()['winPlacePerc'].plot.bar(ax=ax[2])
del sub, walk
```


![png](/img/output_65_0.png)


zombie


```python
# zombie
sub = train.query('walkDistance == 0 & kills == 0 & weaponsAcquired == 0 & \'solo\' in matchType')
print('count:', len(sub), ' winPlacePerc:', round(sub['winPlacePerc'].mean(),3))
```

    count: 18154  winPlacePerc: 0.053


cheater?


```python
sq = 'kills > 3 & (headshotKills / kills) >= 0.8'
sub = train.query(sq)
print(sq, '\n count:', len(sub), ' winPlacePerc:', round(sub['winPlacePerc'].mean(),3))
```

    kills > 3 & (headshotKills / kills) >= 0.8 
     count: 3859  winPlacePerc: 0.824


## killPoints, rankPoints, winPoints


```python
fig, ax = plt.subplots(1, 3, figsize=(16, 4), sharey=True)

cols = ['killPoints','rankPoints','winPoints']
for col, ax in zip(cols, ax.ravel()): 
    train.plot.scatter(x=col, y='winPlacePerc', ax=ax)
```

    'c' argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with 'x' & 'y'.  Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points.
    'c' argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with 'x' & 'y'.  Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points.
    'c' argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with 'x' & 'y'.  Please use a 2-D array with a single row if you really want to specify the same RGB or RGBA value for all points.



```python
sign = lambda x: 'p<=0' if x <= 0 else 'p>0'
pd.concat([
    pd.crosstab(train['rankPoints'].apply(sign), train['winPoints'].apply(sign), margins=False),
    pd.crosstab(train['rankPoints'].apply(sign), train['killPoints'].apply(sign), margins=False)
], keys=['winPoints','killPoints'], axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }

    .dataframe thead tr:last-of-type th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="2" halign="left">winPoints</th>
      <th colspan="2" halign="left">killPoints</th>
    </tr>
    <tr>
      <th>winPoints</th>
      <th>p&lt;=0</th>
      <th>p&gt;0</th>
      <th>p&lt;=0</th>
      <th>p&gt;0</th>
    </tr>
    <tr>
      <th>rankPoints</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>p&lt;=0</th>
      <td>0</td>
      <td>1791319</td>
      <td>0</td>
      <td>1791319</td>
    </tr>
    <tr>
      <th>p&gt;0</th>
      <td>2655647</td>
      <td>0</td>
      <td>2655647</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div>



## winPlacePerc


```python
train['winPlacePerc'].describe()
```




    count   4,446,965.000
    mean            0.473
    std             0.307
    min             0.000
    25%             0.200
    50%             0.458
    75%             0.741
    max             1.000
    Name: winPlacePerc, dtype: float64




```python
print('match count:', train['matchId'].nunique())

maxPlacePerc = train.groupby('matchId')['winPlacePerc'].max()
print('match [not contains 1st place]:', len(maxPlacePerc[maxPlacePerc != 1]))
del maxPlacePerc

sub = train[(train['maxPlace'] > 1) & (train['numGroups'] == 1)]
print('match [maxPlace>1 & numGroups==1]:', len(sub.groupby('matchId')))
print(' - unique winPlacePerc:', sub['winPlacePerc'].unique())
```

    match count: 47965
    match [not contains 1st place]: 75
    match [maxPlace>1 & numGroups==1]: 68
     - unique winPlacePerc: [0.]



```python
pd.concat([train[train['winPlacePerc'] == 1].head(5),
           train[train['winPlacePerc'] == 0].head(5)],
          keys=['winPlacePerc_1', 'winPlacePerc_0'])
```

## match summary


```python
cols = ['kills','teamKills','DBNOs','revives','assists','boosts','heals','damageDealt',
    'walkDistance','rideDistance','swimDistance','weaponsAcquired']

aggs = ['count','min','mean','max']

grp = train.loc[train['matchType'].str.contains('solo')].groupby('matchId')
grpSolo = grp[cols].sum()

grp = train.loc[~train['matchType'].str.contains('solo')].groupby('matchId')
grpTeam = grp[cols].sum()

pd.concat([grpSolo.describe().T[aggs], grpTeam.describe().T[aggs]], keys=['solo', 'team'], axis=1)
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead tr th {
        text-align: left;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="4" halign="left">solo</th>
      <th colspan="4" halign="left">team</th>
    </tr>
    <tr>
      <th></th>
      <th>count</th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
      <th>count</th>
      <th>min</th>
      <th>mean</th>
      <th>max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>kills</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>83.410</td>
      <td>786.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>86.212</td>
      <td>687.000</td>
    </tr>
    <tr>
      <th>teamKills</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>1.023</td>
      <td>15.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>2.455</td>
      <td>76.000</td>
    </tr>
    <tr>
      <th>DBNOs</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>73.377</td>
      <td>669.000</td>
    </tr>
    <tr>
      <th>revives</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>0.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>18.366</td>
      <td>81.000</td>
    </tr>
    <tr>
      <th>assists</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>5.541</td>
      <td>219.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>24.954</td>
      <td>275.000</td>
    </tr>
    <tr>
      <th>boosts</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>94.361</td>
      <td>182.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>104.302</td>
      <td>227.000</td>
    </tr>
    <tr>
      <th>heals</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>90.291</td>
      <td>395.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>134.489</td>
      <td>424.000</td>
    </tr>
    <tr>
      <th>damageDealt</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>10,609.554</td>
      <td>80,991.203</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>12,425.667</td>
      <td>68,960.344</td>
    </tr>
    <tr>
      <th>walkDistance</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>85,056.578</td>
      <td>156,265.719</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>111,468.266</td>
      <td>216,150.875</td>
    </tr>
    <tr>
      <th>rideDistance</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>41,245.410</td>
      <td>207,528.625</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>59,229.430</td>
      <td>370,542.188</td>
    </tr>
    <tr>
      <th>swimDistance</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>452.937</td>
      <td>5,222.350</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>410.993</td>
      <td>9,829.961</td>
    </tr>
    <tr>
      <th>weaponsAcquired</th>
      <td>8,095.000</td>
      <td>0.000</td>
      <td>319.979</td>
      <td>1,860.000</td>
      <td>39,870.000</td>
      <td>0.000</td>
      <td>343.312</td>
      <td>1,666.000</td>
    </tr>
  </tbody>
</table>
</div>




```python
grpSolo.nlargest(5, 'kills')
```


```python
grpTeam.nlargest(5, 'kills')
```


```python
del grpSolo, grpTeam
```

## group summary


```python
cols = ['kills','teamKills','DBNOs','revives','assists','boosts','heals','damageDealt',
    'walkDistance','rideDistance','swimDistance','weaponsAcquired']
cols.extend(['killPlace','winPlacePerc'])
group = train.groupby(['matchId','groupId'])[cols]

fig, ax = plt.subplots(3, 1, figsize=(12, 18), sharey=True)
for df, ax in zip([group.mean(), group.min(), group.max()], ax.ravel()):
    sns.heatmap(df.corr(), annot=True, linewidths=.6, fmt='.2f', vmax=1, vmin=-1, center=0, cmap='Blues', ax=ax)

del df
```


![png](/img/output_83_0.png)


### any match stats


```python
def printMatchStats(matchIds):
    for mid in matchIds:
        subMatch = train[train['matchId'] == mid]
        print('matchType:', subMatch['matchType'].values[0])

        grp1st = subMatch[subMatch['winPlacePerc'] == 1]
        grpOther = subMatch[subMatch['winPlacePerc'] != 1]
        print('players'.ljust(10), ' total:{:>3}  1st:{:>3}  other:{:>3}'.format(len(subMatch), len(grp1st), len(grpOther)))
        for c in ['kills','teamKills','roadKills','DBNOs','revives','assists']:
            print(c.ljust(10), ' total:{:>3}  1st:{:>3}  other:{:>3}'.format(subMatch[c].sum(), grp1st[c].sum(), grpOther[c].sum()))
        print('-' * 30)
```


```python
match = train.groupby(['matchId'])['Id'].count()
fullplayer = match[match == 100].reset_index()
sampleMid = fullplayer['matchId'][0:5]
printMatchStats(sampleMid)
```

    matchType: duo
    players     total:100  1st:  2  other: 98
    kills       total: 95  1st:  6  other: 89
    teamKills   total:  1  1st:  0  other:  1
    roadKills   total:  0  1st:  0  other:  0
    DBNOs       total: 59  1st:  2  other: 57
    revives     total: 11  1st:  0  other: 11
    assists     total: 22  1st:  0  other: 22
    ------------------------------
    matchType: duo-fpp
    players     total:100  1st:  2  other: 98
    kills       total: 93  1st:  8  other: 85
    teamKills   total:  3  1st:  0  other:  3
    roadKills   total:  0  1st:  0  other:  0
    DBNOs       total: 66  1st:  3  other: 63
    revives     total: 16  1st:  1  other: 15
    assists     total: 22  1st:  3  other: 19
    ------------------------------
    matchType: squad-fpp
    players     total:100  1st:  4  other: 96
    kills       total: 90  1st: 10  other: 80
    teamKills   total:  1  1st:  0  other:  1
    roadKills   total:  0  1st:  0  other:  0
    DBNOs       total: 89  1st:  8  other: 81
    revives     total: 21  1st:  2  other: 19
    assists     total: 35  1st:  6  other: 29
    ------------------------------
    matchType: squad-fpp
    players     total:100  1st:  4  other: 96
    kills       total: 93  1st:  4  other: 89
    teamKills   total:  4  1st:  0  other:  4
    roadKills   total:  0  1st:  0  other:  0
    DBNOs       total: 83  1st:  3  other: 80
    revives     total: 13  1st:  1  other: 12
    assists     total: 24  1st:  1  other: 23
    ------------------------------
    matchType: duo-fpp
    players     total:100  1st:  2  other: 98
    kills       total: 95  1st:  4  other: 91
    teamKills   total:  1  1st:  0  other:  1
    roadKills   total:  0  1st:  0  other:  0
    DBNOs       total: 70  1st:  2  other: 68
    revives     total: 24  1st:  1  other: 23
    assists     total: 17  1st:  1  other: 16
    ------------------------------


## Feature Engineering


```python
all_data = train.append(test, sort=False).reset_index(drop=True)
del train, test
gc.collect()
```




    65105



### rank as percent


```python
match = all_data.groupby('matchId')
all_data['killsPerc'] = match['kills'].rank(pct=True).values
all_data['killPlacePerc'] = match['killPlace'].rank(pct=True).values
all_data['walkDistancePerc'] = match['walkDistance'].rank(pct=True).values
#all_data['damageDealtPerc'] = match['damageDealt'].rank(pct=True).values
all_data['walkPerc_killsPerc'] = all_data['walkDistancePerc'] / all_data['killsPerc']

```

### distance


```python
all_data['_totalDistance'] = all_data['rideDistance'] + all_data['walkDistance'] + all_data['swimDistance']
#all_data['_rideBin'] = (all_data['rideDistance'] > 0).astype(int)
#all_data['_swimBin'] = (all_data['swimDistance'] > 0).astype(int)
```

### new feature


```python
def fillInf(df, val):
    numcols = df.select_dtypes(include='number').columns
    cols = numcols[numcols != 'winPlacePerc']
    df[df == np.Inf] = np.NaN
    df[df == np.NINF] = np.NaN
    for c in cols: df[c].fillna(val, inplace=True)
```


```python
all_data['_healthItems'] = all_data['heals'] + all_data['boosts']
all_data['_headshotKillRate'] = all_data['headshotKills'] / all_data['kills']
all_data['_killPlaceOverMaxPlace'] = all_data['killPlace'] / all_data['maxPlace']
all_data['_killsOverWalkDistance'] = all_data['kills'] / all_data['walkDistance']
#all_data['_killsOverDistance'] = all_data['kills'] / all_data['_totalDistance']
#all_data['_walkDistancePerSec'] = all_data['walkDistance'] / all_data['matchDuration']

fillInf(all_data, 0)
```

### drop feature


```python
all_data.drop(['boosts','heals','killStreaks','DBNOs'], axis=1, inplace=True)
all_data.drop(['headshotKills','roadKills','vehicleDestroys'], axis=1, inplace=True)
all_data.drop(['rideDistance','swimDistance','matchDuration'], axis=1, inplace=True)
all_data.drop(['rankPoints','killPoints','winPoints'], axis=1, inplace=True)
```

### grouping


```python
match = all_data.groupby(['matchId'])
group = all_data.groupby(['matchId','groupId','matchType'])

# target feature (max, min)
agg_col = list(all_data.columns)
exclude_agg_col = ['Id','matchId','groupId','matchType','maxPlace','numGroups','winPlacePerc']
for c in exclude_agg_col:
    agg_col.remove(c)
print(agg_col)

# target feature (sum)
sum_col = ['kills','killPlace','damageDealt','walkDistance','_healthItems']

```

    ['assists', 'damageDealt', 'killPlace', 'kills', 'longestKill', 'revives', 'teamKills', 'walkDistance', 'weaponsAcquired', 'killsPerc', 'killPlacePerc', 'walkDistancePerc', 'walkPerc_killsPerc', '_totalDistance', '_healthItems', '_headshotKillRate', '_killPlaceOverMaxPlace', '_killsOverWalkDistance']



```python
''' match sum, match max, match mean, group sum
'''
match_data = pd.concat([
    match.size().to_frame('m.players'), 
    match[sum_col].sum().rename(columns=lambda s: 'm.sum.' + s), 
    match[sum_col].max().rename(columns=lambda s: 'm.max.' + s),
    match[sum_col].mean().rename(columns=lambda s: 'm.mean.' + s)
    ], axis=1).reset_index()
match_data = pd.merge(match_data, 
    group[sum_col].sum().rename(columns=lambda s: 'sum.' + s).reset_index())
match_data = reduce_mem_usage(match_data)

print(match_data.shape)
```

    Memory usage of dataframe is 408.37 MB --> 288.92 MB (Decreased by 29.3%)
    (2912983, 24)



```python
''' ranking of kills and killPlace in each match
'''
minKills = all_data.sort_values(['matchId','groupId','kills','killPlace']).groupby(
    ['matchId','groupId','kills']).first().reset_index().copy()
for n in np.arange(4):
    c = 'kills_' + str(n) + '_Place'
    nKills = (minKills['kills'] == n)
    minKills.loc[nKills, c] = minKills[nKills].groupby(['matchId'])['killPlace'].rank().values
    match_data = pd.merge(match_data, minKills[nKills][['matchId','groupId',c]], how='left')
    #match_data[c].fillna(0, inplace=True)
match_data = reduce_mem_usage(match_data)
del minKills, nKills

print(match_data.shape)
```

    Memory usage of dataframe is 377.81 MB --> 333.36 MB (Decreased by 11.8%)
    (2912983, 28)



```python
''' group mean, max, min
'''
all_data = pd.concat([
    group.size().to_frame('players'),
    group.mean(),
    group[agg_col].max().rename(columns=lambda s: 'max.' + s),
    group[agg_col].min().rename(columns=lambda s: 'min.' + s),
    ], axis=1).reset_index()
all_data = reduce_mem_usage(all_data)

print(all_data.shape)
```

    Memory usage of dataframe is 911.20 MB --> 591.72 MB (Decreased by 35.1%)
    (2912983, 61)


### aggregate feature


```python
numcols = all_data.select_dtypes(include='number').columns.values
numcols = numcols[numcols != 'winPlacePerc']
```


```python
''' match summary, max
'''
all_data = pd.merge(all_data, match_data)
del match_data
gc.collect()

all_data['enemy.players'] = all_data['m.players'] - all_data['players']
for c in sum_col:
    #all_data['enemy.' + c] = (all_data['m.sum.' + c] - all_data['sum.' + c]) / all_data['enemy.players']
    #all_data['p.sum_msum.' + c] = all_data['sum.' + c] / all_data['m.sum.' + c]
    #all_data['p.max_mmean.' + c] = all_data['max.' + c] / all_data['m.mean.' + c]
    all_data['p.max_msum.' + c] = all_data['max.' + c] / all_data['m.sum.' + c]
    all_data['p.max_mmax.' + c] = all_data['max.' + c] / all_data['m.max.' + c]
    all_data.drop(['m.sum.' + c, 'm.max.' + c], axis=1, inplace=True)
    
fillInf(all_data, 0)
print(all_data.shape)
```

    (2912983, 83)



```python
''' match rank
'''
match = all_data.groupby('matchId')
matchRank = match[numcols].rank(pct=True).rename(columns=lambda s: 'rank.' + s)
all_data = reduce_mem_usage(pd.concat([all_data, matchRank], axis=1))
rank_col = matchRank.columns
del matchRank
gc.collect()

match = all_data.groupby('matchId')
matchRank = match[rank_col].max().rename(columns=lambda s: 'max.' + s).reset_index()
all_data = pd.merge(all_data, matchRank)
for c in numcols:
    all_data['rank.' + c] = all_data['rank.' + c] / all_data['max.rank.' + c]
    all_data.drop(['max.rank.' + c], axis=1, inplace=True)
del matchRank
gc.collect()

print(all_data.shape)
```

    Memory usage of dataframe is 2141.87 MB --> 1475.14 MB (Decreased by 31.1%)
    (2912983, 140)


### killPlace rank of group and kills


```python
''' TODO: incomplete
''' 
killMinorRank = all_data[['matchId','min.kills','max.killPlace']].copy()
group = killMinorRank.groupby(['matchId','min.kills'])
killMinorRank['rank.minor.maxKillPlace'] = group.rank(pct=True).values
all_data = pd.merge(all_data, killMinorRank)

killMinorRank = all_data[['matchId','max.kills','min.killPlace']].copy()
group = killMinorRank.groupby(['matchId','max.kills'])
killMinorRank['rank.minor.minKillPlace'] = group.rank(pct=True).values
all_data = pd.merge(all_data, killMinorRank)

del killMinorRank
gc.collect()
```




    70



### delete feature


```python
constant_column = [col for col in all_data.columns if all_data[col].nunique() == 1]
print('drop columns:', constant_column)
all_data.drop(constant_column, axis=1, inplace=True)
```

    drop columns: ['rank.maxPlace', 'rank.numGroups']


### encode


```python
'''
solo  <-- solo,solo-fpp,normal-solo,normal-solo-fpp
duo   <-- duo,duo-fpp,normal-duo,normal-duo-fpp,crashfpp,crashtpp
squad <-- squad,squad-fpp,normal-squad,normal-squad-fpp,flarefpp,flaretpp
'''
all_data['matchType'] = all_data['matchType'].apply(mapper)

all_data = pd.concat([all_data, pd.get_dummies(all_data['matchType'])], axis=1)
all_data.drop(['matchType'], axis=1, inplace=True)

all_data['matchId'] = all_data['matchId'].apply(lambda x: int(x,16))
all_data['groupId'] = all_data['groupId'].apply(lambda x: int(x,16))
```


```python
null_cnt = all_data.isnull().sum().sort_values()
print(null_cnt[null_cnt > 0])
```

    winPlacePerc    886239
    dtype: int64



```python
cols = [col for col in all_data.columns if col not in ['Id','matchId','groupId']]
for i, t in all_data.loc[:, cols].dtypes.iteritems():
    if t == object:
        all_data[i] = pd.factorize(all_data[i])[0]

all_data = reduce_mem_usage(all_data)

```

    Memory usage of dataframe is 1505.70 MB --> 1508.47 MB (Decreased by -0.2%)


## Predict


```python
X_train = all_data[all_data['winPlacePerc'].notnull()].reset_index(drop=True)
X_test = all_data[all_data['winPlacePerc'].isnull()].drop(['winPlacePerc'], axis=1).reset_index(drop=True)
del all_data
gc.collect()

Y_train = X_train.pop('winPlacePerc')
X_test_grp = X_test[['matchId','groupId']].copy()
train_matchId = X_train['matchId']

# drop matchId,groupId
X_train.drop(['matchId','groupId'], axis=1, inplace=True)
X_test.drop(['matchId','groupId'], axis=1, inplace=True)

print(X_train.shape, X_test.shape)
```

    (2026744, 141) (886239, 141)



```python
print(pd.DataFrame([[val for val in dir()], [sys.getsizeof(eval(val)) for val in dir()]],
                   index=['name','size']).T.sort_values('size', ascending=False).reset_index(drop=True)[:10])
```

                name        size
    0        X_train  1043773264
    1         X_test   456413189
    2  train_matchId    16214056
    3     X_test_grp    14179928
    4        Y_train     8107080
    5       null_cnt       27390
    6       rank_col        9201
    7            _i3        1927
    8           cols        1248
    9     GroupKFold        1056



```python
from sklearn.model_selection import GroupKFold
from sklearn.preprocessing import minmax_scale
import lightgbm as lgb

params={'learning_rate': 0.1,
        'objective':'mae',
        'metric':'mae',
        'num_leaves': 31,
        'verbose': 1,
        'random_state':42,
        'bagging_fraction': 0.7,
        'feature_fraction': 0.7
       }

reg = lgb.LGBMRegressor(**params, n_estimators=100)# 为了测试 仅仅选择迭代100次
reg.fit(X_train, Y_train)
pred = reg.predict(X_test, num_iteration=reg.best_iteration_)
```


```python
# Plot feature importance
feature_importance = reg.feature_importances_
feature_importance = 100.0 * (feature_importance / feature_importance.max())
sorted_idx = np.argsort(feature_importance)
sorted_idx = sorted_idx[len(feature_importance) - 30:]
pos = np.arange(sorted_idx.shape[0]) + .5

plt.figure(figsize=(12,8))
plt.barh(pos, feature_importance[sorted_idx], align='center')
plt.yticks(pos, X_train.columns[sorted_idx])
plt.xlabel('Relative Importance')
plt.title('Variable Importance')
plt.show()
```


![png](/img/output_119_0.png)



```python
X_train.columns[np.argsort(-feature_importance)].values
```




    array(['rank.minor.maxKillPlace', 'rank.max.killPlace', 'maxPlace',
           'rank.minor.minKillPlace', 'max.killPlacePerc',
           'rank.max.walkPerc_killsPerc', 'numGroups',
           'rank.max.killPlacePerc', 'rank.max.walkDistance',
           'rank.min._killsOverWalkDistance', 'min.killsPerc',
           'min.killPlace', 'min.killPlacePerc', 'p.max_mmax.killPlace',
           'rank.max._totalDistance', 'max._killPlaceOverMaxPlace',
           'rank.walkDistance', 'p.max_msum.killPlace',
           'max.walkPerc_killsPerc', 'killPlace', 'rank._totalDistance',
           'walkPerc_killsPerc', '_healthItems',
           'rank.max._killPlaceOverMaxPlace', 'rank.players', 'killPlacePerc',
           'weaponsAcquired', 'p.max_msum.walkDistance',
           'rank.max.walkDistancePerc', 'rank.walkPerc_killsPerc',
           'max.killPlace', 'rank._healthItems', 'rank.min.longestKill',
           'rank.weaponsAcquired', 'rank.min.walkPerc_killsPerc',
           'rank.killPlace', 'min.walkPerc_killsPerc', 'm.mean.walkDistance',
           'rank.min.killPlace', 'players', 'rank.killPlacePerc',
           'rank.killsPerc', '_killPlaceOverMaxPlace', 'rank.min.kills',
           'm.players', 'sum.killPlace', 'min._killPlaceOverMaxPlace',
           'killsPerc', 'rank._killsOverWalkDistance', 'm.mean.kills',
           '_totalDistance', 'max._totalDistance', 'max.walkDistancePerc',
           'p.max_mmax.damageDealt', 'rank.min._totalDistance',
           'p.max_msum.damageDealt', 'sum.walkDistance',
           'min._killsOverWalkDistance', 'walkDistancePerc',
           'rank.max.weaponsAcquired', 'max.longestKill', 'walkDistance',
           'duo', 'rank.min.killsPerc', 'rank.max._healthItems',
           'rank.max._killsOverWalkDistance', 'm.mean.killPlace',
           'longestKill', 'damageDealt', 'sum._healthItems',
           'min.weaponsAcquired', 'sum.damageDealt', 'sum.kills',
           'max.walkDistance', 'rank.min._killPlaceOverMaxPlace', 'min.kills',
           'assists', 'rank.revives', 'rank.min.killPlacePerc',
           'p.max_msum._healthItems', 'enemy.players', 'rank.min.assists',
           'rank.min.walkDistancePerc', 'rank.assists',
           'rank.max.damageDealt', 'rank.max.kills', 'rank.max.assists',
           'rank._killPlaceOverMaxPlace', 'min.walkDistancePerc',
           'p.max_mmax.walkDistance', 'max.weaponsAcquired',
           'rank.walkDistancePerc', 'rank.min.walkDistance',
           'rank.max.longestKill', 'rank.min._healthItems', 'squad',
           'min.damageDealt', 'min.longestKill', 'max._healthItems',
           'min.walkDistance', 'max.killsPerc', 'max.kills',
           'p.max_msum.kills', 'max.damageDealt', 'teamKills', 'rank.kills',
           'rank.longestKill', 'kills', '_headshotKillRate',
           'rank.min._headshotKillRate', 'max.assists',
           'max._headshotKillRate', 'max.revives', 'max.teamKills',
           'rank.min.weaponsAcquired', 'revives', 'rank.min.teamKills',
           'rank.min.revives', '_killsOverWalkDistance',
           'max._killsOverWalkDistance', 'rank.numGroups',
           'rank.min.damageDealt', 'rank._headshotKillRate', 'rank.maxPlace',
           'rank.damageDealt', 'p.max_mmax._healthItems', 'solo',
           'rank.max.revives', 'rank.max.teamKills', 'm.mean._healthItems',
           'm.mean.damageDealt', 'rank.max.killsPerc',
           'min._headshotKillRate', 'min._healthItems', 'min._totalDistance',
           'min.teamKills', 'rank.max._headshotKillRate', 'min.revives',
           'rank.teamKills', 'min.assists', 'p.max_mmax.kills'], dtype=object)




```python
X_test_grp['_nofit.winPlacePerc'] = pred

group = X_test_grp.groupby(['matchId'])
X_test_grp['winPlacePerc'] = pred
X_test_grp['_rank.winPlacePerc'] = group['winPlacePerc'].rank(method='min')
X_test = pd.concat([X_test, X_test_grp], axis=1)
```


```python
fullgroup = (X_test['numGroups'] == X_test['maxPlace'])

# full group (201366) --> calculate from rank
subset = X_test.loc[fullgroup]
X_test.loc[fullgroup, 'winPlacePerc'] = (subset['_rank.winPlacePerc'].values - 1) / (subset['maxPlace'].values - 1)

# not full group (684872) --> align with maxPlace
subset = X_test.loc[~fullgroup]
gap = 1.0 / (subset['maxPlace'].values - 1)
new_perc = np.around(subset['winPlacePerc'].values / gap) * gap  # half&up
X_test.loc[~fullgroup, 'winPlacePerc'] = new_perc

X_test['winPlacePerc'] = X_test['winPlacePerc'].clip(lower=0,upper=1)
```

    /Users/liaopeng/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:5: RuntimeWarning: divide by zero encountered in true_divide
      """
    /Users/liaopeng/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:5: RuntimeWarning: invalid value encountered in true_divide
      """



```python
# edge cases
X_test.loc[X_test['maxPlace'] == 0, 'winPlacePerc'] = 0
X_test.loc[X_test['maxPlace'] == 1, 'winPlacePerc'] = 1  # nothing
X_test.loc[(X_test['maxPlace'] > 1) & (X_test['numGroups'] == 1), 'winPlacePerc'] = 0
X_test['winPlacePerc'].describe()
```




    count   886,239.000
    mean          0.499
    std           0.297
    min           0.000
    25%           0.240
    50%           0.500
    75%           0.761
    max           1.000
    Name: winPlacePerc, dtype: float64




```python

```
