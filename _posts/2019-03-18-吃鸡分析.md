---
layout:     post
title:      数据挖掘
subtitle:   助你吃鸡
date:       2019-03-18
author:     LP
header-img: img/post-bg-mma-3.jpg
catalog: true
tags:
    - 健身
    - 生活
    - 学习
    
---

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns 
import warnings
warnings.filterwarnings("ignore")
```


```python
train = pd.read_csv('all/train_V2.csv')
```


```python
train.info()
```

    <class 'pandas.core.frame.DataFrame'>
    RangeIndex: 4446966 entries, 0 to 4446965
    Data columns (total 29 columns):
    Id                 object
    groupId            object
    matchId            object
    assists            int64
    boosts             int64
    damageDealt        float64
    DBNOs              int64
    headshotKills      int64
    heals              int64
    killPlace          int64
    killPoints         int64
    kills              int64
    killStreaks        int64
    longestKill        float64
    matchDuration      int64
    matchType          object
    maxPlace           int64
    numGroups          int64
    rankPoints         int64
    revives            int64
    rideDistance       float64
    roadKills          int64
    swimDistance       float64
    teamKills          int64
    vehicleDestroys    int64
    walkDistance       float64
    weaponsAcquired    int64
    winPoints          int64
    winPlacePerc       float64
    dtypes: float64(6), int64(19), object(4)
    memory usage: 983.9+ MB

groupId - Integer ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.
matchId - Integer ID to identify match. There are no matches that are in both the training and testing set.
assists - Number of enemy players this player damaged that were killed by teammates. /助攻数 
boosts - Number of boost items used.功能性饮料
damageDealt - Total damage dealt. Note: Self inflicted damage is subtracted.造成的总伤害。 注意：减去自己造成的伤害。
DBNOs - 被击倒的敌方玩家数量
headshotKills - 被爆头杀死的敌方玩家数量。
heals - Number of healing items used.使用的治疗物品数 
killPlace - Ranking in match of number of enemy players killed.在被杀死的敌方玩家中的排名/总击杀数排名  
killPoints - Kills-based external ranking of player. 击杀的分
kills - Number of enemy players killed . 击杀敌人的数量
killStreaks - Max number of enemy players killed in a short amount of time. 连杀数量
longestKill - Longest distance between player and player killed at time of death.最远距离击杀
maxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.玩家常出现的位置  
numGroups - Number of groups we have data for in the match.我们在比赛中有数据的组数 
revives - Number of times this player revived teammates.复活队友的次数/拉队友
rideDistance - Total distance traveled in vehicles measured in meters.车辆行驶的总距离
roadKills - Number of kills while in a vehicle.在车辆中击敌人的数量  
swimDistance - Total distance traveled by swimming measured in meters. 总的游泳数量
teamKills - Number of times this player killed a teammate.杀死队友的次数  
vehicleDestroys - Number of vehicles destroyed.毁坏车辆的数量
walkDistance - Total distance traveled on foot measured in meters.步行总次数
weaponsAcquired - Number of weapons picked up.拿起武器数量     
winPoints - 基于Win的玩家外部排名
winPlacePerc - 预测的目标，玩家的单局排名（百分比）


```python
train.head()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Id</th>
      <th>groupId</th>
      <th>matchId</th>
      <th>assists</th>
      <th>boosts</th>
      <th>damageDealt</th>
      <th>DBNOs</th>
      <th>headshotKills</th>
      <th>heals</th>
      <th>killPlace</th>
      <th>...</th>
      <th>revives</th>
      <th>rideDistance</th>
      <th>roadKills</th>
      <th>swimDistance</th>
      <th>teamKills</th>
      <th>vehicleDestroys</th>
      <th>walkDistance</th>
      <th>weaponsAcquired</th>
      <th>winPoints</th>
      <th>winPlacePerc</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>7f96b2f878858a</td>
      <td>4d4b580de459be</td>
      <td>a10357fd1a4a91</td>
      <td>0</td>
      <td>0</td>
      <td>0.00</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>60</td>
      <td>...</td>
      <td>0</td>
      <td>0.0000</td>
      <td>0</td>
      <td>0.00</td>
      <td>0</td>
      <td>0</td>
      <td>244.80</td>
      <td>1</td>
      <td>1466</td>
      <td>0.4444</td>
    </tr>
    <tr>
      <th>1</th>
      <td>eef90569b9d03c</td>
      <td>684d5656442f9e</td>
      <td>aeb375fc57110c</td>
      <td>0</td>
      <td>0</td>
      <td>91.47</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>57</td>
      <td>...</td>
      <td>0</td>
      <td>0.0045</td>
      <td>0</td>
      <td>11.04</td>
      <td>0</td>
      <td>0</td>
      <td>1434.00</td>
      <td>5</td>
      <td>0</td>
      <td>0.6400</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1eaf90ac73de72</td>
      <td>6a4a42c3245a74</td>
      <td>110163d8bb94ae</td>
      <td>1</td>
      <td>0</td>
      <td>68.00</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>47</td>
      <td>...</td>
      <td>0</td>
      <td>0.0000</td>
      <td>0</td>
      <td>0.00</td>
      <td>0</td>
      <td>0</td>
      <td>161.80</td>
      <td>2</td>
      <td>0</td>
      <td>0.7755</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4616d365dd2853</td>
      <td>a930a9c79cd721</td>
      <td>f1f1f4ef412d7e</td>
      <td>0</td>
      <td>0</td>
      <td>32.90</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>75</td>
      <td>...</td>
      <td>0</td>
      <td>0.0000</td>
      <td>0</td>
      <td>0.00</td>
      <td>0</td>
      <td>0</td>
      <td>202.70</td>
      <td>3</td>
      <td>0</td>
      <td>0.1667</td>
    </tr>
    <tr>
      <th>4</th>
      <td>315c96c26c9aac</td>
      <td>de04010b3458dd</td>
      <td>6dc8ff871e21e6</td>
      <td>0</td>
      <td>0</td>
      <td>100.00</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>45</td>
      <td>...</td>
      <td>0</td>
      <td>0.0000</td>
      <td>0</td>
      <td>0.00</td>
      <td>0</td>
      <td>0</td>
      <td>49.75</td>
      <td>2</td>
      <td>0</td>
      <td>0.1875</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 29 columns</p>
</div>




```python
train.kills.value_counts()
```




    0     2529722
    1      928079
    2      472466
    3      232441
    4      124543
    5       66577
    6       37960
    7       21816
    8       12779
    9        7644
    10       4599
    11       2799
    12       1755
    13       1137
    14        757
    15        484
    16        325
    17        234
    18        165
    19        112
    20        109
    22         77
    21         70
    23         47
    24         44
    26         27
    25         27
    28         22
    27         21
    29         13
    30         13
    31         13
    33         12
    36          8
    35          7
    38          7
    34          5
    37          5
    41          5
    32          4
    39          4
    40          4
    53          4
    43          3
    42          3
    44          2
    46          2
    55          2
    56          2
    57          2
    45          1
    47          1
    48          1
    49          1
    50          1
    66          1
    65          1
    72          1
    Name: kills, dtype: int64




```python
sns.kdeplot(data['kills'],cumulative=True)# 绘制累计分布图
plt.show()
```


![png](/img/output_6_0.png)



```python
#sns.axes_style("darkgrid")
sns.set()
#sns.set_style("whitegrid")
#sns.set_style("dark")
#sns.set_style("ticks")
#sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
sns.kdeplot(data['kills'][0:100],cumulative=True,shade=True,color="b")# 绘制累计分布图
sns.despine()# 去掉上面和右边的边框  注意代码的执行顺序
#隐去左边框，可以通过true or false 来操作上，下，左，右边框
#sns.despine(left=True)
plt.show()
```


![png](/img/output_7_0.png)


##  now that we have a glimpse of the data, let's explore them.


```python
print train['kills'].mean()
print train['kills'].quantile(0.99)
print train['kills'].max()
```

    0.924783324181
    7.0
    72


## Let's plot the kill counts.


```python
data = train.copy()
data.loc[data['kills'] > data['kills'].quantile(0.99)] = '8+'
plt.figure(figsize=(15,10))
sns.countplot(data['kills'].astype('str').sort_values())
plt.title("Kill Count",fontsize=15)
plt.show()
```


![png](/img/output_11_0.png)



```python
plt.figure(figsize=(15,10))
sns.countplot(data['kills'].sort_values())
plt.title("Kill Count",fontsize=15)
plt.show()
```


![png](/img/output_12_0.png)


## Most people can't make a single kill. At least do they do damage?


```python
data = train.copy()
data = data[data['kills']==0]
plt.figure(figsize=(15,10))
plt.title("Damage Dealt by 0 killers",fontsize=15)
sns.distplot(data['damageDealt'])
plt.show()
```


![png](/img/output_14_0.png)


## Well, most of them don't. Let's investigate the exceptions.


```python
# 成功吃鸡 但是一个人都没杀
print len(data[data['winPlacePerc']==1])
print "%.4f"%(float(100*len(data[data['winPlacePerc']==1]))/float(len(train)))
```

    16666
    0.3748



```python
# 成功吃鸡 但是没有造成任何伤害
data1 = train[train['damageDealt'] == 0].copy()
print len(data1[data1['winPlacePerc']==1])
print "%.4f"%(float(100*len(data1[data1['winPlacePerc']==1]))/float(len(train)))
```

    4770
    0.1073


## Plot win placement percentage vs kills.


```python
sns.jointplot(x="winPlacePerc", y="kills", data=train, height=10, ratio=3, color="r")
plt.show()
```


![png](/img/output_19_0.png)


## Apparentrly killing has a correlation with winning. Finally let's group players based on kills (0 kills, 1-2 kills, 3-5 kills, 6-10 kills and 10+ kills).


```python
kills = train.copy()
kills['killsCategories'] = pd.cut(kills['kills'], [-1, 0, 2, 5, 10, 60], labels=['0_kills','1-2_kills', '3-5_kills', '6-10_kills', '10+_kills'])
plt.figure(figsize=(15,8))
sns.boxplot(x="killsCategories", y="winPlacePerc", data=kills)
plt.show()
```


![png](/img/output_21_0.png)



```python
print("The average person walks for {:.1f}m, 99% of people have walked {}m or less, while the marathoner champion walked for {}m.".format(train['walkDistance'].mean(), train['walkDistance'].quantile(0.99), train['walkDistance'].max()))
```

    The average person walks for 1154.2m, 99% of people have walked 4396.0m or less, while the marathoner champion walked for 25780.0m.



```python
print train['walkDistance'].mean() # The average person walks 
print train['walkDistance'].quantile(0.99)#99% of people have walked 4396.0m or less
print train['walkDistance'].max()# the marathoner champion
```

    1154.2178591
    4396.0
    25780.0



```python
data = train.copy()
data = data[data['walkDistance'] < train['walkDistance'].quantile(0.99)]
plt.figure(figsize=(15,10))
plt.title("Walking Distance Distribution",fontsize=15)
sns.distplot(data['walkDistance'])
plt.show()
```


![png](/img/output_24_0.png)



```python
print("{} players ({:.4f}%) walked 0 meters. This means that they die before even taking a step or they are afk (more possible).".format(len(data[data['walkDistance'] == 0]), 100*len(data1[data1['walkDistance']==0])/len(train)))
```

    99603 players (2.0000%) walked 0 meters. This means that they die before even taking a step or they are afk (more possible).



```python
print len(data[data['walkDistance'] == 0])
print "%.4f"%(float(100*len(data1[data1['walkDistance']==0]))/float(len(train)))
```

    99603
    2.0329



```python
sns.jointplot(x="winPlacePerc", y="walkDistance",  data=train, height=10, ratio=3, color="lime")
plt.show()
## Apparently walking has a high correlation with winPlacePerc.
```


![png](/img/output_27_0.png)


## The Drivers


```python
print("The average person drives for {:.1f}m, 99% of people have drived {}m or less, while the formula 1 champion drived for {}m.".format(train['rideDistance'].mean(), train['rideDistance'].quantile(0.99), train['rideDistance'].max()))
```

    The average person drives for 606.1m, 99% of people have drived 6966.0m or less, while the formula 1 champion drived for 40710.0m.



```python
print train['rideDistance'].mean()#average person drives
print train['rideDistance'].quantile(0.99)#99% of people have drived
print train['rideDistance'].max()#the formula 1 champion drived
```

    606.115669154
    6966.0
    40710.0



```python
data = train.copy()
data = data[data['rideDistance'] < train['rideDistance'].quantile(0.9)]
plt.figure(figsize=(15,10))
plt.title("Ride Distance Distribution",fontsize=15)
sns.distplot(data['rideDistance'])
plt.show()
```


![png](/img/output_31_0.png)



```python
print("{} players ({:.4f}%) drived for 0 meters. This means that they don't have a driving licence yet.".format(len(data[data['rideDistance'] == 0]), 100*len(data1[data1['rideDistance']==0])/len(train)))
```

    3309429 players (23.0000%) drived for 0 meters. This means that they don't have a driving licence yet.



```python
sns.jointplot(x="winPlacePerc", y="rideDistance", data=train, height=10, ratio=3, color="y")
plt.show()
#There is a small correlation between rideDistance and winPlacePerc.
```


![png](/img/output_33_0.png)


## Destroying a vehicle in my experience shows that a player has skills. Let's check it.


```python
f,ax1 = plt.subplots(figsize =(20,10))
sns.pointplot(x='vehicleDestroys',y='winPlacePerc',data=data,color='#606060',alpha=0.8)
plt.xlabel('Number of Vehicle Destroys',fontsize = 15,color='blue')
plt.ylabel('Win Percentage',fontsize = 15,color='blue')
plt.title('Vehicle Destroys/ Win Ratio',fontsize = 20,color='blue')
plt.grid()
plt.show()
#My experience was correct. Destroying a single vehicle increases your chances of winning!
```


![png](/img/output_35_0.png)


## The Swimmers


```python
print("The average person swims for {:.1f}m, 99% of people have swimemd {}m or less, while the olympic champion swimmed for {}m.".format(train['swimDistance'].mean(), train['swimDistance'].quantile(0.99), train['swimDistance'].max()))
```

    The average person swims for 4.5m, 99% of people have swimemd 123.0m or less, while the olympic champion swimmed for 3823.0m.



```python
data = train.copy()
data = data[data['swimDistance'] < train['swimDistance'].quantile(0.95)]
plt.figure(figsize=(15,10))
plt.title("Swim Distance Distribution",fontsize=15)
sns.distplot(data['swimDistance'])
plt.show()
# Almost no one swims. Let's group the swimming distances in 4 categories and plot vs winPlacePerc.
```


![png](/img/output_38_0.png)



```python
swim = train.copy()

swim['swimDistance'] = pd.cut(swim['swimDistance'], [-1, 0, 5, 20, 5286], labels=['0m','1-5m', '6-20m', '20m+'])

plt.figure(figsize=(15,8))
sns.boxplot(x="swimDistance", y="winPlacePerc", data=swim)
plt.show()
# It seems that if you swim, you rise to the top. In PUBG there are currently 3 maps. 
# One of them has almost no water. Keep that in mind. 
# I might plan on doing analysis to find out in which map a match is played.
```


![png](/img/output_39_0.png)


## The Healers


```python
print("The average person uses {:.1f} heal items, 99% of people use {} or less, while the doctor used {}.".format(train['heals'].mean(), train['heals'].quantile(0.99), train['heals'].max()))
print("The average person uses {:.1f} boost items, 99% of people use {} or less, while the doctor used {}.".format(train['boosts'].mean(), train['boosts'].quantile(0.99), train['boosts'].max()))
```

    The average person uses 1.4 heal items, 99% of people use 12.0 or less, while the doctor used 80.
    The average person uses 1.1 boost items, 99% of people use 7.0 or less, while the doctor used 33.



```python
data = train.copy()
data = data[data['heals'] < data['heals'].quantile(0.99)]
data = data[data['boosts'] < data['boosts'].quantile(0.99)]

f,ax1 = plt.subplots(figsize =(20,10))
sns.pointplot(x='heals',y='winPlacePerc',data=data,color='lime',alpha=0.8)
sns.pointplot(x='boosts',y='winPlacePerc',data=data,color='blue',alpha=0.8)
plt.text(4,0.6,'Heals',color='lime',fontsize = 17,style = 'italic')
plt.text(4,0.55,'Boosts',color='blue',fontsize = 17,style = 'italic')
plt.xlabel('Number of heal/boost items',fontsize = 15,color='blue')
plt.ylabel('Win Percentage',fontsize = 15,color='blue')
plt.title('Heals vs Boosts',fontsize = 20,color='blue')
plt.grid()
plt.show()
```


![png](/img/output_42_0.png)



```python
sns.jointplot(x="winPlacePerc", y="heals", data=train, height=10, ratio=3, color="lime")
plt.show()
```


![png](/img/output_43_0.png)



```python
sns.jointplot(x="winPlacePerc", y="boosts", data=train, height=10, ratio=3, color="blue")
plt.show()
## So healing and boosting, definitely are correlated with winPlacePerc. Boosting is more.

## In every plot, there is an abnormal behavior when values are 0.
```


![png](/img/output_44_0.png)


## Solos, Duos and Squads
There are 3 game modes in the game. One can play solo, or with a friend (duo), or with 3 other friends (squad). 100 players join the same server, so in the case of duos the max teams are 50 and in the case of squads the max teams are 25.


```python
solos = train[train['numGroups']>50]
duos = train[(train['numGroups']>25) & (train['numGroups']<=50)]
squads = train[train['numGroups']<=25]
print("There are {} ({:.2f}%) solo games, {} ({:.2f}%) duo games and {} ({:.2f}%) squad games.".format(len(solos), 100*len(solos)/len(train), len(duos), 100*len(duos)/len(train), len(squads), 100*len(squads)/len(train),))
```

    There are 709111 (15.00%) solo games, 3295326 (74.00%) duo games and 442529 (9.00%) squad games.



```python
f,ax1 = plt.subplots(figsize =(20,10))
sns.pointplot(x='kills',y='winPlacePerc',data=solos,color='black',alpha=0.8)
sns.pointplot(x='kills',y='winPlacePerc',data=duos,color='#CC0000',alpha=0.8)
sns.pointplot(x='kills',y='winPlacePerc',data=squads,color='#3399FF',alpha=0.8)
plt.text(37,0.6,'Solos',color='black',fontsize = 17,style = 'italic')
plt.text(37,0.55,'Duos',color='#CC0000',fontsize = 17,style = 'italic')
plt.text(37,0.5,'Squads',color='#3399FF',fontsize = 17,style = 'italic')
plt.xlabel('Number of kills',fontsize = 15,color='blue')
plt.ylabel('Win Percentage',fontsize = 15,color='blue')
plt.title('Solo vs Duo vs Squad Kills',fontsize = 20,color='blue')
plt.grid()
plt.show()
```


![png](/img/output_47_0.png)


Hmm, very interesting. Solos and duos behave the same, but when playing squads kills don't matter that much.

The attribute DBNOs means enemy players knocked. A "knock" can happen only in duos or squads, because the teammates have the chance to "revive" the knocked player in a given time. So a knocked player can be revived or die. If he is revived, the next time he will be knocked, his teammates will have less time to revive him.

The attribute assist can also happen only in duos or squads. It generally means that the player had an involvement in a kill.

The attribute revive also happens in duos or squads.

## Pearson correlation between variables


```python
f,ax = plt.subplots(figsize=(15, 15))
sns.heatmap(train.corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax)
plt.show()
```


![png](/img/output_50_0.png)


In terms of the target variable (winPlacePerc), there are a few variables high medium to high correlation. The highest positive correlation is walkDistance and the highest negative the killPlace.

## Let's zoom to the top-5 most positive correlated variables with the target.


```python
k = 5 #number of variables for heatmap
f,ax = plt.subplots(figsize=(11, 11))
cols = train.corr().nlargest(k, 'winPlacePerc')['winPlacePerc'].index
cm = np.corrcoef(train[cols].values.T)
sns.set(font_scale=1.25)
hm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)
plt.show()
```


![png](/img/output_53_0.png)


Let's plot the above variables and the killPlace variable as pairs.


```python
sns.set()
cols = ['winPlacePerc', 'walkDistance', 'boosts', 'weaponsAcquired', 'damageDealt', 'killPlace']
data  = train.dropna()
sns.pairplot(data[cols], size = 2.5)
plt.show()
```


![png](/img/output_55_0.png)



![png](/img/output_55_1.png)



```python
train[cols].isnull().any()
```




    winPlacePerc        True
    walkDistance       False
    boosts             False
    weaponsAcquired    False
    damageDealt        False
    killPlace          False
    dtype: bool



## Feature Engineering

A game in PUBG can have up to 100 players fighting each other. But most of the times a game isn't "full". There is no variable that gives us the number of players joined. So lets create one.


```python
train['playersJoined'] = train.groupby('matchId')['matchId'].transform('count')
```


```python
data = train.copy()
data = data[data['playersJoined']>49]
plt.figure(figsize=(15,10))
sns.countplot(data['playersJoined'])
plt.title("Players Joined",fontsize=15)
plt.show()
```

Based on the "playersJoined" feature we can create (or change) a lot of others to normalize their values. 
For example i will create the "killsNorm" and "damageDealtNorm" features. 
When there are 100 players in the game it might be easier to find and kill someone, than when there are 90 players. 
So i will normalize the kills in a way that a kill in 100 players will score 1 (as it is) and in 90 players it will score (100-90)/100 + 1 = 1.1. 
This is just an assumption. You can use different scales.


```python

```
